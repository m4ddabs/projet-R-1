
```{r, echo = FALSE}
#To run first
#Imports of packages
library('tidyverse')
library("ggforce") #for graphs
library("dplyr") #for sql data manipulation
library("sqldf")
```
```{r, echo = FALSE}

getwd()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))


#Imports of databases add "../" in front of file path before compiling in R mark down
cancero <- read.csv(file = "Donnees-20221103/CANCERO_2019.csv",
                    header = TRUE, sep = ";", dec = ".")

desc_cancero <- read.csv(file = "Donnees-20221103/Desc_Cancero_Urgences.csv",
                         header = TRUE, sep = ",", dec = ".")

urgences2019  <- read.csv(file = "Donnees-20221103/URGENCES2_2019.csv",
                         header = TRUE, sep = ";", dec = ".")

urgences2020  <- read.csv(file = "Donnees-20221103/URGENCES2_2020.csv",
                         header = TRUE, sep = ";", dec = ".")

Q20 <- read.csv(file = "Donnees-20221103/Q20_2019.csv",
                         header = TRUE, sep = ";", dec = ".")

desc_Q20 <- read.csv(file = "Donnees-20221103/Desc_Q20.csv",
                         header = TRUE, sep = ",", dec = ".")

```

```{r, echo = FALSE}
#attach databases, only run once
attach(cancero)
attach(desc_cancero)
index <- desc_cancero$Valeur.Modalité == "CANCERO_A1"
desc_cancero[index]
```

```{r}
#Define functions

#given an iterable X returns a vector without doublons of elements in L
no_doublons <- function(X){
      L <- list()
      for (x in X){
            if (! x %in% L){
                  L <- c(L,x)
            }
      }
      return(L)
}

#sum excluding na values
sum2 <- function(vector) {
      return(sum(vector[! is.na(vector)]))
}
```
# First part of the project

### Cancero
1. Quel est le nombre de patients adulte (âge > ou égal à 18 ans) atteints de cancer ayant eu un traitement
par chimiothérapie dans l’année en MCO (variable CANCERO_A11) ?

```{r}
N_chem_adults_MCO <- sum(CANCERO_A11[! is.na(CANCERO_A11)])
```
2. Comparer la proportion des adultes atteints de cancer ayant eu un traitement par chimiothérapie
(MCO et HAD) en hospitalisation à domicile (HAD, variable CANCERO_B11) à la proportion des enfants
ayant eu un traitement par chimiothérapie en hospitalisation à domicile (les variables CANCERO_C11 et
CANCERO_D11 correspondent aux nombre de patients de moins de 18 ans atteints de cancer ayant eu un
traitement par chimiothérapie dans l’année en MCO et HAD respectivement).
```{r}
N_chem_adults_HAD <- sum(CANCERO_B11[! is.na(CANCERO_B11)]) 
N_chem_childs_MCO <- sum(CANCERO_C11[! is.na(CANCERO_C11)]) 
N_chem_childs_HAD <- sum(CANCERO_D11[! is.na(CANCERO_D11)]) 

HAD_tot <- N_chem_adults_HAD + N_chem_childs_HAD
MCO_tot <- N_chem_adults_MCO + N_chem_childs_MCO
print(paste("The HAD adults percentage is:", as.character(N_chem_adults_HAD/HAD_tot),
      " The MCO adults percentage is: ", as.character(N_chem_adults_MCO/MCO_tot)))
#use sprintf
```
3. Créer une variable Patients contenant pour chaque hôpital le nombre total de personnes ayant eu
un traitement par chimiothérapie (enfants et adultes, en MCO ou HAD). 
Représenter graphiquement
1 le nombre de médecins oncologues médicaux effectifs équivalent temps plein (variable CANCERO_C28)
en fonction du nombre de Patients. Commenter les résultats. Faire un zoom sur le graphique en ne
représentant que les hôpitaux ayant moins de 2000 patients
```{r}
cancero$Patients = CANCERO_A11 + CANCERO_B11 + CANCERO_C11 + CANCERO_D11


ggplot(cancero)+ #zoom
      geom_point(aes(x = Patients, y = CANCERO_C28), col = "red")+
      facet_zoom(xlim = c(0, 2000))

```

Urgences
1. Dans les unités des urgences générales (celles pour lesquelles URG == "GEN"), comparer le nombre total
de passages aux urgences en 2019 pour des patients de plus de 80 ans au nombre total de passages aux
urgences dans la même année pour des patients de moins de 18 ans (variables dt80 et dt18). Quelle est
l’unité d’urgence générale pour laquelle la proportion de patients de moins de 18 ans est la plus élevée ?

```{r}
#il y a un souci ici je pense A REVOIR
#urgenero <- merge(cancero, urgences, by = "FI") #inner join
urgtot <- urgences2019$dt80 + urgences2019$dt18
prop <- urgences2019$dt18 / urgtot
sprintf("l’unité d’urgence générale pour laquelle la proportion de patients de moins de 18 ans est la plus élevée est FI = %s", 
         urgences2019$FI[which.max(prop)])
```
2. Dans combien d’unites générales a-t-on rajouté des lits en 2020 par rapport à 2019 ? La variable
LIT_UHCD contient le nombre de lits installés au 31/12.

```{r}
nb_unit_lit_nouveaux <- 0
nb_lit_nouveaux<-urgences2019[urgences2019$URG == "GEN","LIT_UHCD"]-urgences2020[urgences2019$URG == "GEN", "LIT_UHCD"]
nb_lit_nouveaux<-nb_lit_nouveaux[!is.na(nb_lit_nouveaux)]
for(i in seq(1,length(nb_lit_nouveaux))){
  if (nb_lit_nouveaux[i] > 0){
    nb_unit_lit_nouveaux <- nb_unit_lit_nouveaux +1
  }
}
sprintf("nombre d’unites générales qui ont rajoute des lits en 2020 par rapport a 2019 : %i", nb_unit_lit_nouveaux)
```


3. Représenter graphiquement l’évolution de la moyenne annuelle du nombre total de passages aux urgences
dans les unités générales entre 2017 et 2021. Indication : la variable PASSU donne le nombre total de
passages aux urgences dans l’année.


Q20
1. Quelle est la proportion de données manquantes pour chaque variable ?
```{r}
d = dim(Q20)
colran = 1:d[2]
rowran = 1:d[1]
for (i in colran) {
      n_na = length(rowran[is.na(Q20[,i])])  
      name = names(Q20)[i]
      print(sprintf("La proportion de donnèes manquantes de %s est %.3f per cent",
                     name,  n_na/d[1]*100))
}

```
2. Calculer la proportion d’hommes dans l’effectif des salariés temps plein pour chaque spécialité. Les
spécialités peuvent être retrouvées en regardant les modalités de la variable PERSO. Afficher à chaque fois
le nom de la spécialité (en utilisant les informations du fichier DescPerso.csv) dont cette proportion
est :
* la plus grande
* la plus petite
* la plus proche de 1/2.

We run an SQL request with sqldf to get the IDs of the specialities and their labels
We then create a table containing the proportions of men in the various jobs.
```{r}
#I STILL NEED TO POLISH IT o(*^＠^*)o
#maybe i should've add it directly as a new vairable but ok
#trying to use sqsl in R
#Names of all specialities, last is "total"
specialites <- sqldf('select distinct "Label.modalité", "Valeur.Modalité"
                from desc_Q20
                where "Variable" = "EFFSALPLF" or
                      "Variable" = "EFFSALPLH"')

propH <- t(rbind(specialites[, 1], specialites[, 2], specialites[,1])) #has one row for every speciality and 3 columns
len <- dim(propH)[1]

#Could've also added a new variable to specialites
for (i in 1:len) {
      job <- propH[i,]
      H_indices <- Q20$"PERSO" == job[2]
      F_indices <- Q20$"PERSO" == job[2]
      Hommes_job_total <- sum2(Q20$"EFFSALPLH"[H_indices])
      Femmes_job_total <- sum2(Q20$"EFFSALPLF"[F_indices])
      job_total <- Hommes_job_total + Femmes_job_total

      propH[i,3] <- Hommes_job_total / job_total
}
```
We calculate the various requests of the exercise.

* Speciality with the higher percentage of man
```{r}
i <- which.max(propH[,3])
sprintf("%s has a male staff percentage of %.2f%%", propH[i,1], as.double(propH[i,3])*100)
```

* Speciality with the lowest percentage of man
```{r}
i <- which.min(propH[,3])
sprintf("%s has a male staff percentage of %.2f%%", propH[i,1], as.double(propH[i,3])*100)
```

* * Speciality with percentage closest to 50%

```{r}
dist_vector <- abs(as.double(propH[,3]) - 1/2)
i <- which.min(propH[,3])
sprintf("%s has a male staff percentage of %.2f%%", propH[i,1], as.double(propH[i,3])*100)
```

3. Ordonner les spécialités en fonction du nombre total d’effectif équivalent temps plein (ETP) des hospi-
taliers universitaires titulaires (variable ETP_PU). Afficher les 10 premières. Représenter graphiquement
par un diagramme en barre ce nombre pour les 5 premières.

We add a variable (ETP_tot) to the table specialites containing the total of ETP for each speciality
```{r}

specialites$ETP_tot <- rep(0,len)

for (i in 1:len) {
      indices <- Q20$"PERSO" == specialites[i,2] #finds indices corresponding to speciality ID
      tot_ETP <- sum2(Q20$"ETP_PU"[indices])
      specialites$ETP_tot[i] <- tot_ETP
}

ordered_specialites <- specialites[order(specialites$ETP_tot, decreasing = TRUE),]

```

We print the first 5 specialities with the highest total ETP and print a column graph
```{r}

indices <- c(1,3)
print(ordered_specialites[2:6,indices]) #the first line is the total

```