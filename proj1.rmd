
```{r, echo = FALSE}
#To run first
#Imports of packages
library('tidyverse')
library("ggforce") #for graphs
library("dplyr") #for sql data manipulation
library("sqldf")
library("lmtest") #for Breusch-Pagan Test for etero
```
```{r, echo = FALSE}

getwd()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

cancero <- read.csv(file = "Donnees-20221103/CANCERO_2019.csv",
                    header = TRUE, sep = ";", dec = ".")

desc_cancero <- read.csv(file = "Donnees-20221103/Desc_Cancero_Urgences.csv",
                         header = TRUE, sep = ",", dec = ".")

urgences2017  <- read.csv(file = "Donnees-20221103/URGENCES2_2017.csv",
                         header = TRUE, sep = ";", dec = ".")

urgences2018  <- read.csv(file = "Donnees-20221103/URGENCES2_2018.csv",
                         header = TRUE, sep = ";", dec = ".")

urgences2019  <- read.csv(file = "Donnees-20221103/URGENCES2_2019.csv",
                         header = TRUE, sep = ";", dec = ".")

urgences2020  <- read.csv(file = "Donnees-20221103/URGENCES2_2020.csv",
                         header = TRUE, sep = ";", dec = ".")

urgences2021  <- read.csv(file = "Donnees-20221103/URGENCES2_2021.csv",
                         header = TRUE, sep = ";", dec = ".")

Q20 <- read.csv(file = "Donnees-20221103/Q20_2019.csv",
                         header = TRUE, sep = ";", dec = ".")

desc_Q20 <- read.csv(file = "Donnees-20221103/Desc_Q20.csv",
                         header = TRUE, sep = ",", dec = ".")

```

```{r, echo = FALSE}
#attach databases, only run once
attach(cancero)
attach(desc_cancero)

```

```{r, echo = FALSE}
#Define functions

#given an iterable X returns a vector without doublons of elements in L
no_doublons <- function(X){
      L <- list()
      for (x in X){
            if (! x %in% L){
                  L <- c(L,x)
            }
      }
      return(L)
}

#sum excluding na values
sum2 <- function(vector) {
      return(sum(vector[! is.na(vector)]))
}

#calculates and plots regression confidence interval
reg_conf_interval <- function(x,y) {
  
  n <- sum(!is.na(x + y))
  lm.model <- lm(y ~ x) # Fit linear model
  
  # Extract coefficients
  b0 <- lm.model$coefficients[1]
  b1 <- lm.model$coefficients[2]
  
}
```
# First part of the project

### Cancero
1. Quel est le nombre de patients adulte (âge > ou égal à 18 ans) atteints de cancer ayant eu un traitement
par chimiothérapie dans l’année en MCO (variable CANCERO_A11) ?

```{r}
N_chem_adults_MCO <- sum(CANCERO_A11[! is.na(CANCERO_A11)])
print(N_chem_adults_MCO)
```
2. Comparer la proportion des adultes atteints de cancer ayant eu un traitement par chimiothérapie
(MCO et HAD) en hospitalisation à domicile (HAD, variable CANCERO_B11) à la proportion des enfants
ayant eu un traitement par chimiothérapie en hospitalisation à domicile (les variables CANCERO_C11 et
CANCERO_D11 correspondent aux nombre de patients de moins de 18 ans atteints de cancer ayant eu un
traitement par chimiothérapie dans l’année en MCO et HAD respectivement).
```{r}
N_chem_adults_HAD <- sum(CANCERO_B11[! is.na(CANCERO_B11)]) 
N_chem_childs_MCO <- sum(CANCERO_C11[! is.na(CANCERO_C11)]) 
N_chem_childs_HAD <- sum(CANCERO_D11[! is.na(CANCERO_D11)]) 

HAD_tot <- N_chem_adults_HAD + N_chem_childs_HAD
MCO_tot <- N_chem_adults_MCO + N_chem_childs_MCO
sprintf("The HAD adults percentage is :%.2f%%
         The MCO adults percentage is: %.2f%% ",N_chem_adults_HAD/HAD_tot*100,           N_chem_adults_MCO/MCO_tot*100)
```
3. Créer une variable Patients contenant pour chaque hôpital le nombre total de personnes ayant eu
un traitement par chimiothérapie (enfants et adultes, en MCO ou HAD). 
Représenter graphiquement
1 le nombre de médecins oncologues médicaux effectifs équivalent temps plein (variable CANCERO_C28)
en fonction du nombre de Patients. Commenter les résultats. Faire un zoom sur le graphique en ne
représentant que les hôpitaux ayant moins de 2000 patients
```{r}
cancero$Patients <- CANCERO_A11 + CANCERO_B11 + CANCERO_C11 + CANCERO_D11


ggplot(cancero) + 
      geom_point(aes(x = Patients, y = CANCERO_C28), col = "red")+
      facet_zoom(xlim = c(0, 2000)) #zoom

```

Urgences
1. Dans les unités des urgences générales (celles pour lesquelles URG == "GEN"), comparer le nombre total
de passages aux urgences en 2019 pour des patients de plus de 80 ans au nombre total de passages aux
urgences dans la même année pour des patients de moins de 18 ans (variables dt80 et dt18). Quelle est
l’unité d’urgence générale pour laquelle la proportion de patients de moins de 18 ans est la plus élevée ?

```{r}
#il y a un souci ici je pense A REVOIR
#urgenero <- merge(cancero, urgences, by = "FI") #inner join
urgtot <- urgences2019[urgences2019$URG== "GEN", "dt80"] + urgences2019[urgences2019$URG == "GEN", "dt18"]
prop <- urgences2019[urgences2019$URG== "GEN", "dt80"] / urgtot
sprintf("l’unité d’urgence générale pour laquelle la proportion de patients de moins de 18 ans est la plus élevée est FI = %s", 
         urgences2019[urgences2019$URG =="GEN", ]$FI[which.max(prop)])
```
2. Dans combien d’unites générales a-t-on rajouté des lits en 2020 par rapport à 2019 ? La variable
LIT_UHCD contient le nombre de lits installés au 31/12.

```{r}
nb_unit_lit_nouveaux <-0
urgences2019_2020<-merge(urgences2019[urgences2019$URG == "GEN",],urgences2020[urgences2020$URG == "GEN",], by="FI")
nb_lit_nouveaux<-urgences2019_2020[,"LIT_UHCD.x"]-urgences2019_2020[, "LIT_UHCD.y"]
nb_lit_nouveaux<-nb_lit_nouveaux[!is.na(nb_lit_nouveaux)]
for(i in seq(1,length(nb_lit_nouveaux))){
  if (nb_lit_nouveaux[i] > 0){
    nb_unit_lit_nouveaux <- nb_unit_lit_nouveaux +1
  }
}
sprintf("nombre d’unites générales qui ont rajoute des lits en 2020 par rapport a 2019 : %i", nb_unit_lit_nouveaux)
```
Donc nous trouvons qu'il y a 21 unités générales qui ont des nouveaux lits.  

3. Représenter graphiquement l’évolution de la moyenne annuelle du nombre total de passages aux urgences dans les unités générales entre 2017 et 2021. Indication : la variable PASSU donne le nombre total de
passages aux urgences dans l’année.

```{r}
moy_2017<-mean(urgences2017[urgences2017$URG == "GEN","PASSU"],na.rm=TRUE)
moy_2018<-mean(urgences2018[urgences2018$URG == "GEN","PASSU"],na.rm=TRUE)
moy_2019<-mean(urgences2019[urgences2019$URG == "GEN","PASSU"],na.rm=TRUE)
moy_2020<-mean(urgences2020[urgences2020$URG == "GEN","PASSU"],na.rm=TRUE)
moy_2021<-mean(urgences2021[urgences2021$URG == "GEN","PASSU"],na.rm=TRUE)

moy_an<-c(moy_2017,moy_2018,moy_2019,moy_2020,moy_2021)
annee<- c(2017,2018,2019,2020,2021)
evo_an<-data.frame(annee, moy_an)

ggplot(data = evo_an, aes(x=annee, y=moy_an )) + 
  geom_line(color = "red", linetype = 5) +
   ggtitle("evolution moyenne")
```



Q20
1. Quelle est la proportion de données manquantes pour chaque variable ?
```{r}
d = dim(Q20)
colran = 1:d[2]
rowran = 1:d[1]
for (i in colran) {
      n_na = length(rowran[is.na(Q20[,i])])  
      name = names(Q20)[i]
      print(sprintf("La proportion de donnèes manquantes de %s est %.3f per cent",
                     name,  n_na/d[1]*100))
}

```
2. Calculer la proportion d’hommes dans l’effectif des salariés temps plein pour chaque spécialité. Les
spécialités peuvent être retrouvées en regardant les modalités de la variable PERSO. Afficher à chaque fois
le nom de la spécialité (en utilisant les informations du fichier DescPerso.csv) dont cette proportion
est :
* la plus grande
* la plus petite
* la plus proche de 1/2.

We run an SQL request with sqldf to get the IDs of the specialities and their labels
We then create a table containing the proportions of men in the various jobs.
```{r}

#Names of all specialities, last is "total"
specialites <- sqldf('select distinct "Label.modalité", "Valeur.Modalité"
                      from desc_Q20
                      where "Variable" = "EFFSALPLF" or
                      "Variable" = "EFFSALPLH"')

propH <- t(rbind(specialites[, 1], specialites[, 2], specialites[,1])) #has one row for every speciality and 3 columns
len <- dim(propH)[1]

#Could've also added a new variable to specialites
for (i in 1:len) {
      job <- propH[i,]
      H_indices <- Q20$"PERSO" == job[2]
      F_indices <- Q20$"PERSO" == job[2]
      Hommes_job_total <- sum2(Q20$"EFFSALPLH"[H_indices])
      Femmes_job_total <- sum2(Q20$"EFFSALPLF"[F_indices])
      job_total <- Hommes_job_total + Femmes_job_total

      propH[i,3] <- Hommes_job_total / job_total
}
```
We calculate the various requests of the exercise.

* Speciality with the higher percentage of man
```{r}
i <- which.max(propH[,3])
sprintf("%s has a male staff percentage of %.2f%%", propH[i,1], as.double(propH[i,3])*100)
```

* Speciality with the lowest percentage of man
```{r}
i <- which.min(propH[,3])
sprintf("%s has a male staff percentage of %.2f%%", propH[i,1], as.double(propH[i,3])*100)
```

* * Speciality with percentage closest to 50%

```{r}
dist_vector <- abs(as.double(propH[,3]) - 1/2)
i <- which.min(propH[,3])
sprintf("%s has a male staff percentage of %.2f%%", propH[i,1], as.double(propH[i,3])*100)
```

3. Ordonner les spécialités en fonction du nombre total d’effectif équivalent temps plein (ETP) des hospi-
taliers universitaires titulaires (variable ETP_PU). Afficher les 10 premières. Représenter graphiquement
par un diagramme en barre ce nombre pour les 5 premières.

We add a variable (ETP_tot) to the table specialites containing the total of ETP for each speciality
```{r}

specialites$ETP_tot <- rep(0,len)

for (i in 1:len) {
      indices <- Q20$"PERSO" == specialites[i,2] #finds indices corresponding to speciality ID
      tot_ETP <- sum2(Q20$"ETP_PU"[indices])
      specialites$ETP_tot[i] <- tot_ETP
}

ordered_specialites <- specialites[order(specialites$ETP_tot, decreasing = TRUE),]

```

We print the first 5 specialities with the highest total ETP and print a column graph
```{r}
indices <- c(1,3)
print(ordered_specialites[2:6,indices]) #the first line is the total
short_ordered_specialites <- ordered_specialites[2:6,]

barplot(height = short_ordered_specialites[,3], names.arg = short_ordered_specialites[,2], legend.text = "Specialities with higher total ETP", col = "green")


```

# Description et analyse des Données
### Etude de la relation entre le nombre de médecins oncologues médicaux ETP et nombre de patients.

Dans le graph de l'exercise 3 de CANCERo on observe que il y a un tendance de variance croissante avec la variable Patients, on dois donc testè l'hétéroscédasticité pour povoir appliquè la regression lineaire. On fait ça avec le Test de Breusch-Pagan.
```{r}
#variables we care about: Patients, CANCERO_C28 of cancero
model_cancero <- lm(CANCERO_C28 ~ Patients, data = cancero)
bptest(model_cancero)

```
Le p-value est 5.689e-12. Donc il est plut petit de 0.05, on rejet l'hypothese null et il y a  de l'hétéroscédasticité dans le modele.

Nous transformon la variable Patients pour éliminer l'hétéroscédasticité en prenant le log des les deux variables. 

```{r}
cancero$log_Patients <- log10(cancero$Patients)
#cancero$log_Patients[is.infinite(cancero$log_Patients),] <- NA 
cancero$log_CANCERO_C28 <- log10(cancero$CANCERO_C28)
cancero$log_CANCERO_C28[is.infinite(cancero$log_CANCERO_C28)] <- NA 
model2_cancero <- lm(log_CANCERO_C28 ~ log_Patients, data = cancero)
bptest(model2_cancero)

```
```{r}
summary(model2_cancero)
```

Pour pouvoir faire une regression lineaire Gaussienne on test que le bruits de le nouveau modele suive une distribution Gaussienne avec le test de normalité de Shapiro-Wilk. Comme la valeur p est inférieure à 0.05 la distribution des bruits est significativement différente de la distribution gaussienne.
```{r}
b0 <- model2_cancero$coefficients[1]
b1 <- model2_cancero$coefficients[2]
bruits_cancero <- cancero$log_CANCERO_C28 - cancero$log_Patients*b1 - b0
shapiro.test(bruits_cancero)
hist(bruits_cancero)

```

```{r}
ggplot(cancero, aes(x=log_Patients, y=log_CANCERO_C28)) + 
  geom_point(color='#2980B9', size = 4) + 
  geom_smooth(method=lm, color='#2C3E50')

```

